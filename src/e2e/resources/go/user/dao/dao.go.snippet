package dao

	import(
	"database/sql"
	"fmt"
	"time"

	"github.com/squat/and/dab/templeuser/util"
	"github.com/google/uuid"

	// pq acts as the driver for SQL requests
	_"github.com/lib/pq"
	)

// Datastore provides the interface adopted by the DAO, allowing for mocking
	type Datastore interface{
	ListTempleuser()(*[]Templeuser,error)
	CreateTempleuser(input CreateTempleuserInput)(*Templeuser,error)
	ReadTempleuser(input ReadTempleuserInput)(*Templeuser,error)
	UpdateTempleuser(input UpdateTempleuserInput)(*Templeuser,error)
}

// DAO encapsulates access to the datastore
	type DAO struct{
	DB*sql.DB
}

// Templeuser encapsulates the object stored in the datastore
	type Templeuser struct{
	ID uuid.UUID
	CreatedBy uuid.UUID
	Username string
	Email string
	FirstName string
	LastName string
	CreatedAt time.Time
	NumberOfDogs int32
	Yeets bool
	CurrentBankBalance float32
	BirthDate time.Time
	BreakfastTime time.Time
}

// CreateTempleuserInput encapsulates the information required to create a single templeuser in the datastore
	type CreateTempleuserInput struct{
	ID uuid.UUID
	AuthID uuid.UUID
	Username string
	Email string
	FirstName string
	LastName string
	CreatedAt time.Time
	NumberOfDogs int32
	Yeets bool
	CurrentBankBalance float32
	BirthDate time.Time
	BreakfastTime time.Time
}

// ReadTempleuserInput encapsulates the information required to read a single templeuser in the datastore
	type ReadTempleuserInput struct{
	ID uuid.UUID
}

// UpdateTempleuserInput encapsulates the information required to update a single templeuser in the datastore
	type UpdateTempleuserInput struct{
	ID uuid.UUID
	Username string
	Email string
	FirstName string
	LastName string
	CreatedAt time.Time
	NumberOfDogs int32
	Yeets bool
	CurrentBankBalance float32
	BirthDate time.Time
	BreakfastTime time.Time
}

// Init opens the datastore connection, returning a DAO
	func Init(config*util.Config)(*DAO,error){
	connStr:=fmt.Sprintf("user=%s dbname=%s host=%s sslmode=%s",config.User,config.DBName,config.Host,config.SSLMode)
	db,err:=sql.Open("postgres",connStr)
	if err!=nil{
	return nil,err
}
	return&DAO{db},nil
}

// Executes a query, returning the rows
	func executeQueryWithRowResponses(db*sql.DB,query string,args...interface{})(*sql.Rows,error){
	return db.Query(query,args...)
}

// Executes a query, returning the row
	func executeQueryWithRowResponse(db*sql.DB,query string,args...interface{})*sql.Row{
	return db.QueryRow(query,args...)
}

// CreateTempleuser creates a new templeuser in the datastore, returning the newly created templeuser
	func(dao*DAO)CreateTempleuser(input CreateTempleuserInput)(*Templeuser,error){
	return nil,nil
}

// ReadTempleuser returns the templeuser in the datastore for a given ID
	func(dao*DAO)ReadTempleuser(input ReadTempleuserInput)(*Templeuser,error){
	return nil,nil
}

// UpdateTempleuser updates the templeuser in the datastore for a given ID, returning the newly updated templeuser
	func(dao*DAO)UpdateTempleuser(input UpdateTempleuserInput)(*Templeuser,error){
	return nil,nil
}

// ListTempleuser returns a list containing every templeuser in the datastore
	func(dao*DAO)ListTempleuser()(*[]Templeuser,error){
	rows,err:=executeQueryWithRowResponses(dao.DB,"SELECT username, email, firstName, lastName, createdAt, numberOfDogs, yeets, currentBankBalance, birthDate, breakfastTime FROM templeuser;",)
	if err!=nil{
	return nil,err
}

	templeuserList:=make([]Templeuser,0)
	for rows.Next(){
	var templeuser Templeuser
	err=rows.Scan(&templeuser.ID,&templeuser.CreatedBy,&templeuser.Username,&templeuser.Email,&templeuser.FirstName,&templeuser.LastName,&templeuser.CreatedAt,&templeuser.NumberOfDogs,&templeuser.Yeets,&templeuser.CurrentBankBalance,&templeuser.BirthDate,&templeuser.BreakfastTime)
	if err!=nil{
	return nil,err
}
	templeuserList=append(templeuserList,templeuser)
}
	err=rows.Err()
	if err!=nil{
	return nil,err
}

	return&templeuserList,nil
}
